import { defineStore } from 'pinia'
import { dataService } from '../services/dataService.js'
import { useToastStore } from './toast.js'
import tagsData from '../data/tags.json'

// Cl√©s pour le localStorage
const OFFLINE_QUEUE_KEY = 'easysholi_offline_queue'
const OFFLINE_DATA_KEY = 'easysholi_offline_data'

export const useShoppingListStore = defineStore('shoppingList', {
  state: () => ({
    currentList: null,
    items: [],
    tags: tagsData.tags,
    selectedTags: [],
    isModalOpen: false,
    loading: false,
    error: null,
    isOnline: navigator.onLine,
    pendingSync: false,
    offlineQueue: [],
  }),

  getters: {
    filteredItems: (state) => {
      if (state.selectedTags.length === 0) {
        return state.items
      }
      return state.items.filter((item) => state.selectedTags.includes(item.tagId))
    },

    getTagById: (state) => (id) => {
      return state.tags.find((tag) => tag.id === id)
    },

    completedItemsCount: (state) => {
      return state.items.filter((item) => item.completed).length
    },

    totalItemsCount: (state) => state.items.length,

    uncompletedItems() {
      return this.filteredItems.filter((item) => !item.completed)
    },

    completedItems() {
      return this.filteredItems.filter((item) => item.completed)
    },

    hasOfflineData: (state) => state.offlineQueue.length > 0,

    connectionStatus() {
      if (!this.isOnline) return 'offline'
      if (this.pendingSync) return 'syncing'
      return 'online'
    },
  },

  actions: {
    // ===== GESTION HORS LIGNE =====
    saveToLocalStorage(key, data) {
      try {
        localStorage.setItem(key, JSON.stringify(data))
      } catch (error) {
        console.error('‚ùå Erreur sauvegarde locale:', error)
      }
    },

    getFromLocalStorage(key) {
      try {
        const data = localStorage.getItem(key)
        return data ? JSON.parse(data) : null
      } catch (error) {
        console.error('‚ùå Erreur r√©cup√©ration locale:', error)
        return null
      }
    },

    addToOfflineQueue(action) {
      const queueItem = {
        ...action,
        timestamp: Date.now(),
        id: `offline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      }

      this.offlineQueue.push(queueItem)
      this.saveToLocalStorage(OFFLINE_QUEUE_KEY, this.offlineQueue)

      this.showToast(`üì¶ Action sauvegard√©e hors ligne`, 'warning')
    },

    loadOfflineQueue() {
      this.offlineQueue = this.getFromLocalStorage(OFFLINE_QUEUE_KEY) || []
    },

    clearOfflineQueue() {
      this.offlineQueue = []
      localStorage.removeItem(OFFLINE_QUEUE_KEY)
    },

    saveOfflineData(listId, items) {
      const offlineData = this.getFromLocalStorage(OFFLINE_DATA_KEY) || {}
      offlineData[listId] = {
        items: items,
        lastModified: Date.now(),
      }
      this.saveToLocalStorage(OFFLINE_DATA_KEY, offlineData)
    },

    getOfflineData(listId) {
      const offlineData = this.getFromLocalStorage(OFFLINE_DATA_KEY) || {}
      return offlineData[listId] || null
    },

    // ===== GESTION DES TOASTS =====
    showToast(message, type = 'info') {
      // Utilisation du store toast avec import statique
      const toastStore = useToastStore()
      toastStore.show(message, type)
    },

    // ===== INITIALIZATION =====
    init() {
      // Charger la queue hors ligne
      this.loadOfflineQueue()

      // Configure les √©couteurs de connectivit√©
      window.addEventListener('online', () => this.handleOnline())
      window.addEventListener('offline', () => this.handleOffline())

      // Met √† jour l'√©tat initial
      this.isOnline = navigator.onLine

      if (this.isOnline && this.offlineQueue.length > 0) {
        this.syncOfflineData()
      }
    },

    async handleOnline() {
      this.isOnline = true
      this.showToast('üåê Connexion r√©tablie', 'info')

      if (this.offlineQueue.length > 0) {
        await this.syncOfflineData()
      }
    },

    handleOffline() {
      this.isOnline = false
      this.showToast('üì¥ Mode hors ligne activ√©', 'warning')
    },

    async syncOfflineData() {
      if (!this.isOnline || this.pendingSync || this.offlineQueue.length === 0) return

      this.pendingSync = true
      this.showToast('üîÑ Synchronisation en cours...', 'sync')

      try {
        let successCount = 0
        const failedActions = []

        for (const action of this.offlineQueue) {
          try {
            const result = await this.executeOfflineAction(action)
            successCount

            // Si c'√©tait une cr√©ation de liste offline, mettre √† jour la liste actuelle
            if (
              action.type === 'UPDATE_LIST' &&
              typeof action.data.listId === 'string' &&
              action.data.listId.startsWith('offline_') &&
              result
            ) {
              this.currentList = result
            }
          } catch (error) {
            console.error(`‚ùå √âchec synchronisation action ${action.type}:`, error)
            failedActions.push(action)
          }
        }

        // Mettre √† jour la queue avec seulement les actions qui ont √©chou√©
        this.offlineQueue = failedActions
        this.saveToLocalStorage(OFFLINE_QUEUE_KEY, this.offlineQueue)

        if (failedActions.length === 0) {
          this.clearOfflineQueue()
          this.showToast('üåê Donn√©es synchronis√©es', 'success')

          // Recharger les donn√©es depuis le serveur pour s'assurer de la coh√©rence
          if (this.currentList && this.currentList.profile_id) {
            await this.loadShoppingList(this.currentList.profile_id, false)
          }
        } else {
          this.showToast(`‚ö†Ô∏è ${failedActions.length} actions ont √©chou√©`, 'warning')
        }
      } catch (error) {
        console.error('‚ùå Erreur lors de la synchronisation:', error)
        this.error = 'Erreur lors de la synchronisation des donn√©es'
        this.showToast('‚ùå Erreur de synchronisation', 'error')
      } finally {
        this.pendingSync = false
      }
    },

    async executeOfflineAction(action) {
      switch (action.type) {
        case 'CREATE_LIST': {
          return await dataService.createShoppingList(action.data.profileId, action.data.items)
        }

        case 'UPDATE_LIST': {
          // Si c'est une liste offline, on doit d'abord cr√©er une vraie liste
          if (typeof action.data.listId === 'string' && action.data.listId.startsWith('offline_')) {
            // Pour les listes offline, on fusionne avec les donn√©es existantes
            const profileId = action.data.listId.replace('offline_', '')
            const existingLists = await dataService.getShoppingLists(profileId)
            const localItems = action.data.items || []

            if (existingLists.length > 0) {
              // Une liste existe d√©j√†, fusionner les donn√©es
              const serverItems = await dataService.getShoppingItems(existingLists[0].id)
              const mergedItems = this.mergeItems(serverItems, localItems)

              return await dataService.updateShoppingList(existingLists[0].id, mergedItems)
            } else {
              // Pas de liste existante, on cr√©e une nouvelle
              return await dataService.createShoppingList(profileId, action.data.items)
            }
          } else {
            // Pour les listes r√©elles, on fusionne aussi pour √©viter l'√©crasement
            const currentList = await dataService.getShoppingLists(action.data.profileId)
            if (currentList.length > 0) {
              const serverItems = currentList[0].items || []
              const localItems = action.data.items || []
              const mergedItems = this.mergeItems(serverItems, localItems)

              return await dataService.updateShoppingList(action.data.listId, mergedItems)
            } else {
              return await dataService.updateShoppingList(action.data.listId, action.data.items)
            }
          }
        }

        case 'ADD_ITEM': {
          const currentList = await dataService.getShoppingLists(action.data.profileId)
          if (currentList.length > 0) {
            const items = currentList[0].items || []
            // V√©rifier si l'item n'existe pas d√©j√†
            if (!items.find((item) => item.id === action.data.item.id)) {
              items.push(action.data.item)
              return await dataService.updateShoppingList(currentList[0].id, items)
            } else {
              return currentList[0]
            }
          }
          break
        }

        case 'UPDATE_ITEM': {
          const listForUpdate = await dataService.getShoppingLists(action.data.profileId)
          if (listForUpdate.length > 0) {
            const items = listForUpdate[0].items || []
            const itemIndex = items.findIndex((item) => item.id === action.data.itemId)
            if (itemIndex !== -1) {
              // Fusionner les modifications avec gestion des conflits par timestamp
              const serverItem = items[itemIndex]
              const localUpdates = action.data.updates

              // Si on a des timestamps, prendre le plus r√©cent
              if (serverItem.updatedAt && localUpdates.updatedAt) {
                const serverTime = new Date(serverItem.updatedAt).getTime()
                const localTime = new Date(localUpdates.updatedAt).getTime()

                if (localTime > serverTime) {
                  items[itemIndex] = { ...serverItem, ...localUpdates }
                  console.log('üîÑ Modification locale plus r√©cente appliqu√©e:', serverItem.name)
                } else {
                  console.log(
                    '‚ö†Ô∏è Modification serveur plus r√©cente, synchronisation ignor√©e:',
                    serverItem.name,
                  )
                  return listForUpdate[0]
                }
              } else {
                // Pas de timestamp, on applique les modifications locales
                items[itemIndex] = { ...serverItem, ...localUpdates }
              }

              return await dataService.updateShoppingList(listForUpdate[0].id, items)
            }
          }
          break
        }

        case 'DELETE_ITEM': {
          const listForDelete = await dataService.getShoppingLists(action.data.profileId)
          if (listForDelete.length > 0) {
            const items = listForDelete[0].items.filter((item) => item.id !== action.data.itemId)
            return await dataService.updateShoppingList(listForDelete[0].id, items)
          }
          break
        }

        default:
          throw new Error(`Type d'action non support√©: ${action.type}`)
      }
    },

    // ===== FUSION INTELLIGENTE DES ITEMS =====
    mergeItems(serverItems, localItems) {
      const mergedItems = [...serverItems]
      const serverIds = new Set(serverItems.map((item) => item.id))

      // Cr√©er un index des noms normalis√©s pour d√©tecter les doublons
      const serverNameMap = new Map()
      serverItems.forEach((item, index) => {
        const normalizedName = this.normalizeName(item.name)
        serverNameMap.set(normalizedName, { item, index })
      })

      localItems.forEach((localItem) => {
        const localNormalizedName = this.normalizeName(localItem.name)
        const existingByName = serverNameMap.get(localNormalizedName)

        if (!serverIds.has(localItem.id)) {
          // Nouveau ID local
          if (existingByName) {
            // M√™me nom mais ID diff√©rent = doublon d√©tect√©
            console.log(
              `üîç Doublon d√©tect√©: "${localItem.name}" existe d√©j√† comme "${existingByName.item.name}"`,
            )

            // Fusionner les informations (prendre le plus r√©cent ou merger les quantit√©s)
            const serverItem = existingByName.item
            const mergedItem = this.mergeDuplicateItems(serverItem, localItem)
            mergedItems[existingByName.index] = mergedItem

            this.showToast(`üîÑ "${localItem.name}" fusionn√© avec l'existant`, 'info')
          } else {
            // Vraiment nouveau item
            mergedItems.push(localItem)
            console.log('‚ûï Nouvel item local ajout√©:', localItem.name)
          }
        } else {
          // Item existant avec m√™me ID, fusionner en cas de conflit
          const serverItemIndex = mergedItems.findIndex((item) => item.id === localItem.id)
          const serverItem = mergedItems[serverItemIndex]

          // Gestion des conflits par timestamp
          if (serverItem.updatedAt && localItem.updatedAt) {
            const serverTime = new Date(serverItem.updatedAt).getTime()
            const localTime = new Date(localItem.updatedAt).getTime()

            if (localTime > serverTime) {
              mergedItems[serverItemIndex] = { ...serverItem, ...localItem }
              console.log('üîÑ Modification locale plus r√©cente:', localItem.name)
            } else {
              console.log('‚ö†Ô∏è Modification serveur conserv√©e:', serverItem.name)
            }
          } else if (localItem.updatedAt) {
            // Le local a un timestamp mais pas le serveur, prendre le local
            mergedItems[serverItemIndex] = { ...serverItem, ...localItem }
            console.log('üîÑ Modification locale appliqu√©e:', localItem.name)
          }
          // Si aucun timestamp ou que le serveur est plus r√©cent, on garde la version serveur
        }
      })

      return mergedItems
    },

    // ===== NORMALISATION ET FUSION DES DOUBLONS =====
    normalizeName(name) {
      return name.toLowerCase().trim().replace(/\s+/g, ' ')
    },

    mergeDuplicateItems(serverItem, localItem) {
      // Prendre la version la plus r√©cente bas√©e sur les timestamps
      if (serverItem.updatedAt && localItem.updatedAt) {
        const serverTime = new Date(serverItem.updatedAt).getTime()
        const localTime = new Date(localItem.updatedAt).getTime()

        if (localTime > serverTime) {
          // Version locale plus r√©cente, mais garder l'ID du serveur
          return {
            ...localItem,
            id: serverItem.id, // Garder l'ID original pour √©viter les doublons futurs
            quantity: (serverItem.quantity || 1) + (localItem.quantity || 1), // Additionner les quantit√©s
            updatedAt: localItem.updatedAt,
          }
        } else {
          // Version serveur plus r√©cente, mais peut-√™tre additionner les quantit√©s
          return {
            ...serverItem,
            quantity: (serverItem.quantity || 1) + (localItem.quantity || 1),
            updatedAt: serverItem.updatedAt,
          }
        }
      } else {
        // Pas de timestamps, fusionner en additionnant les quantit√©s
        return {
          ...serverItem,
          quantity: (serverItem.quantity || 1) + (localItem.quantity || 1),
          updatedAt: new Date().toISOString(),
        }
      }
    },

    // ===== GESTION DE LA LISTE COURANTE =====
    async loadShoppingList(profileId, useOfflineFirst = true) {
      this.loading = true
      this.error = null
      try {
        // Si hors ligne ou si demand√©, essayer d'abord les donn√©es locales
        if (useOfflineFirst && (!this.isOnline || this.getOfflineData(profileId))) {
          const offlineData = this.getOfflineData(profileId)
          if (offlineData) {
            console.log('üì± Chargement des donn√©es hors ligne')
            this.items = offlineData.items
            this.currentList = {
              id: `offline_${profileId}`,
              profile_id: profileId,
              items: offlineData.items,
            }

            // Si on est en ligne, essayer de synchroniser en arri√®re-plan
            if (this.isOnline) {
              this.syncOfflineData()
            }
            return
          }
        }

        // Chargement depuis le serveur
        if (this.isOnline) {
          const lists = await dataService.getShoppingLists(profileId)

          if (lists.length > 0) {
            // Prendre la liste la plus r√©cente
            this.currentList = lists[0]
            this.items = this.currentList.items || []
          } else {
            // Cr√©er une nouvelle liste si aucune n'existe
            this.currentList = await dataService.createShoppingList(profileId, [])
            this.items = []
          }

          // Sauvegarder en local
          this.saveOfflineData(profileId, this.items)
          console.log('‚úÖ Liste de courses charg√©e depuis le serveur:', this.currentList.id)
          this.showToast('‚úÖ Liste charg√©e', 'success')
        } else {
          // Hors ligne et pas de donn√©es locales
          console.log("üì¥ Hors ligne: cr√©ation d'une liste temporaire")
          this.currentList = {
            id: `offline_${profileId}`,
            profile_id: profileId,
            items: [],
          }
          this.items = []
        }
      } catch (error) {
        console.error('‚ùå Erreur lors du chargement de la liste:', error)
        this.error = 'Erreur lors du chargement de la liste de courses'

        // En cas d'erreur, essayer les donn√©es hors ligne
        const offlineData = this.getOfflineData(profileId)
        if (offlineData) {
          console.log('üîÑ Utilisation des donn√©es hors ligne de secours')
          this.items = offlineData.items
          this.currentList = {
            id: `offline_${profileId}`,
            profile_id: profileId,
            items: offlineData.items,
          }
          this.showToast('üì± Donn√©es hors ligne charg√©es', 'warning')
        } else {
          this.items = []
          this.currentList = null
          this.showToast('‚ùå Erreur de chargement', 'error')
        }
      } finally {
        this.loading = false
      }
    },

    async saveShoppingList() {
      if (!this.currentList) return

      // Toujours sauvegarder en local en premier
      this.saveOfflineData(this.currentList.profile_id, this.items)

      // Si en ligne, essayer de sauvegarder sur le serveur
      if (this.isOnline) {
        this.loading = true
        this.error = null
        try {
          // Si c'est une liste offline, on doit la cr√©er en base
          if (
            typeof this.currentList.id === 'string' &&
            this.currentList.id.startsWith('offline_')
          ) {
            console.log("üîÑ Cr√©ation d'une nouvelle liste en base pour les donn√©es hors ligne")
            const newList = await dataService.createShoppingList(
              this.currentList.profile_id,
              this.items,
            )
            this.currentList = newList
            console.log('‚úÖ Nouvelle liste cr√©√©e:', newList.id)
            this.showToast('‚úÖ Liste cr√©√©e en ligne', 'success')
          } else {
            // Mise √† jour d'une liste existante
            const updatedList = await dataService.updateShoppingList(
              this.currentList.id,
              this.items,
            )
            this.currentList = updatedList
            console.log('‚úÖ Liste sauvegard√©e sur le serveur')
            this.showToast('‚úÖ Donn√©es sauvegard√©es', 'success')
          }
        } catch (error) {
          console.error('‚ùå Erreur lors de la sauvegarde serveur:', error)
          // Ajouter √† la queue hors ligne
          this.addToOfflineQueue({
            type: 'UPDATE_LIST',
            data: {
              listId: this.currentList.id,
              items: this.items,
              profileId: this.currentList.profile_id,
            },
          })
          console.log('üì¶ Action ajout√©e √† la queue hors ligne')
        } finally {
          this.loading = false
        }
      } else {
        // Hors ligne: ajouter √† la queue
        this.addToOfflineQueue({
          type: 'UPDATE_LIST',
          data: {
            listId: this.currentList.id,
            items: this.items,
            profileId: this.currentList.profile_id,
          },
        })
        console.log('üì¥ Sauvegarde hors ligne, ajout√©e √† la queue')
      }
    },

    // ===== GESTION DES ITEMS =====
    async addItem(newItem) {
      const item = {
        id: Date.now().toString(),
        name: newItem.name,
        quantity: newItem.quantity || 1,
        tagId: newItem.tagId,
        completed: false,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      }

      this.items.push(item)
      await this.saveShoppingList()

      // Toast de confirmation
      this.showToast(`‚ûï "${item.name}" ajout√© √† la liste`, 'success')
    },

    async updateItem(itemId, updates) {
      const index = this.items.findIndex((item) => item.id === itemId)
      if (index !== -1) {
        const oldItem = { ...this.items[index] }
        this.items[index] = {
          ...this.items[index],
          ...updates,
          updatedAt: new Date().toISOString(),
        }
        await this.saveShoppingList()

        // Toast sp√©cifique selon le type de mise √† jour
        if (updates.completed !== undefined) {
          const action = updates.completed ? 'termin√©' : 'r√©activ√©'
          this.showToast(
            `${updates.completed ? '‚úÖ' : 'üîÑ'} "${oldItem.name}" ${action}`,
            'success',
          )
        } else {
          this.showToast(`‚úèÔ∏è "${oldItem.name}" modifi√©`, 'info')
        }
      }
    },

    async toggleItemCompleted(itemId) {
      const item = this.items.find((item) => item.id === itemId)
      if (item) {
        item.completed = !item.completed
        item.updatedAt = new Date().toISOString()
        await this.saveShoppingList()

        // Toast sp√©cifique
        const action = item.completed ? 'termin√©' : 'r√©activ√©'
        const icon = item.completed ? '‚úÖ' : 'üîÑ'
        this.showToast(`${icon} "${item.name}" ${action}`, 'success')
      }
    },

    async deleteItem(itemId) {
      const item = this.items.find((item) => item.id === itemId)
      const itemName = item ? item.name : '√âl√©ment'

      this.items = this.items.filter((item) => item.id !== itemId)
      await this.saveShoppingList()

      // Toast de confirmation
      this.showToast(`üóëÔ∏è "${itemName}" supprim√©`, 'info')
    },

    async clearCompleted() {
      const completedCount = this.items.filter((item) => item.completed).length
      this.items = this.items.filter((item) => !item.completed)
      await this.saveShoppingList()

      if (completedCount > 0) {
        this.showToast(
          `üßπ ${completedCount} √©l√©ment${completedCount > 1 ? 's' : ''} supprim√©${completedCount > 1 ? 's' : ''}`,
          'info',
        )
      }
    },

    // ===== GESTION DES FILTRES =====
    toggleTagFilter(tagId) {
      const index = this.selectedTags.indexOf(tagId)
      if (index > -1) {
        this.selectedTags.splice(index, 1)
      } else {
        this.selectedTags.push(tagId)
      }
    },

    clearFilters() {
      this.selectedTags = []
    },

    // ===== GESTION DE LA MODAL =====
    openModal() {
      this.isModalOpen = true
    },

    closeModal() {
      this.isModalOpen = false
    },

    // ===== NETTOYAGE =====
    reset() {
      this.currentList = null
      this.items = []
      this.selectedTags = []
      this.isModalOpen = false
      this.loading = false
      this.error = null
      this.isOnline = navigator.onLine
      this.pendingSync = false
    },
  },
})
